
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'optionsGraph.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5.QtCore import QSize, pyqtSlot, pyqtSignal, Qt
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QPalette, QColor
from PyQt5.QtWidgets import QTabBar, QStylePainter, QStyleOptionTab
import numpy as np
from dataHandling.Constants import Constants
from dataHandling.DataStructures import DetailObject
from .OptionPositionWindow import OptionPositionWindow
from uiComps.customWidgets.OptionTabWidget import OptionTabWidget, SpecOptionTabWidget
import sys

from dataHandling.TradeManagement.PositionDataManagement import PositionDataManager
from dataHandling.UserDataManagement import fetchPositionNotes, writePositionNotes

class OptionPositions(OptionPositionWindow):

    current_tab = None
    position_manager = None
    price_signal_request = pyqtSignal(DetailObject)

    def __init__(self, position_manager):
        super().__init__()
        self.position_manager = position_manager
        self.data_object = self.position_manager.getDataObject()
        self.data_object.position_signal.connect(self.positionUpdate, Qt.QueuedConnection)
        self.price_signal_request.connect(self.position_manager.requestMarketData, Qt.QueuedConnection)
        self.notes = fetchPositionNotes()
        
        self.setupTabBar()


    def setupTabBar(self):
        self.myTabBar = MyTabBar(self.tabWidget.tabBar())
        self.tabWidget.setTabBar(self.myTabBar) 
        self.tabWidget.currentChanged.connect(self.tabSelection)
        self.createMainTab()


    def createMainTab(self):
        self.main_tab = OptionTabWidget(self.data_object, Constants.OPTION)
        self.tabWidget.addTab(self.main_tab, "All")
        self.main_tab.tab_name = "All"

    
    def tabSelection(self, index):
        print("OptionPositions.tabSelection")
        if index > 0:
            self.current_tab = self.tabWidget.currentWidget()
        else:
            self.current_tab = None

        selected_instr = self.tabWidget.tabText(index)
        positions = self.data_object.getOptionPositions()
        self.price_signal_request.emit(DetailObject(symbol=selected_instr))
        

    @pyqtSlot(str, dict)
    def positionUpdate(self, signal, sub_signal):
        print(f"OptionPositions.positionUpdate {signal}")
        print(sub_signal)
        if signal == Constants.DATA_WILL_CHANGE:
            self.processData()
        elif signal == Constants.UNDERLYING_PRICE_UPDATE:
            if self.current_tab is not None:
                self.current_tab.setPrice(self.position_manager.price)
        elif signal == Constants.CONTRACT_DETAILS_FINISHED:
            while self.position_manager.hasNewItem():
                item = self.position_manager.getLatestItem()
                

    def createRectPixmap(self, col=QtGui.QColor(240,50,50)):
        px = QtGui.QPixmap(50,32)
        px.fill(QtCore.Qt.transparent)
        pxSize = px.rect().adjusted(1,1,-1,-1)
        painter = QtGui.QPainter(px)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        painter.setBrush(col)
        painter.setPen(QtGui.QPen(QtGui.QColor(150,20,20), 1.25))
        painter.drawRect(pxSize)
        painter.end()
        return px


    def notesUpdate(self, signal):
        tab_index = self.findIndexForSymbol(signal)
        tab = self.tabWidget.widget(tab_index)
        new_text = tab.notes_window.toPlainText()
        self.notes[signal] = new_text
        writePositionNotes(self.notes)


    def processData(self):

        positions = self.data_object.getOptionPositions()
        for instrument in positions[Constants.SYMBOL].unique():
            if not self.tabExists(instrument):
                instrument_tab = self.addOptionTab(instrument)
                self.setNotes()
                self.myTabBar.update()


    def setNotes(self):
        for symbol, note in self.notes.items():
            tab_index = self.findIndexForSymbol(symbol)
            if tab_index >= 0:
                self.tabWidget.widget(tab_index).notes_window.setPlainText(note)


    def orderExpiration(self):
        tab_count = self.tabWidget.count()

        exp_list = np.empty((tab_count), dtype=int)
        exp_list[0] = -1   # we set the "All" tab to -1 one so that it automatically comes first
        for tab_index in range(1, tab_count):
            days_till = self.tabWidget.widget(tab_index).days_to_expiration
            exp_list[tab_index] = (days_till)

        sorted_exp = np.argsort(exp_list)

        sorted_names = list(map(self.tabWidget.tabText, sorted_exp))
        
        for sorted_name in reversed(sorted_names):
            symbol_index = self.findIndexForSymbol(sorted_name)
            self.myTabBar.moveTab(symbol_index, 0)


    def orderValue(self):
        tab_count = self.tabWidget.count()

        value_list = np.empty((tab_count), dtype=float)
        value_list[0] = -1   # we set the "All" tab to -1 one so that it automatically comes first
        for tab_index in range(1, tab_count):
            value_list[tab_index] = abs(self.tabWidget.widget(tab_index).total_value)

        sorted_value = np.argsort(value_list)

        sorted_names = list(map(self.tabWidget.tabText, sorted_value))
        # logger.printLine(sorted_names)
        # logger.printLine(type(sorted_names))
        
        for sorted_name in reversed(sorted_names):
            symbol_index = self.findIndexForSymbol(sorted_name)
            self.myTabBar.moveTab(symbol_index, 0)


    def findIndexForSymbol(self, symbol):
        for index in range(self.tabWidget.count()):
            if self.tabWidget.tabText(index) == symbol:
                return index

        return -1


    def addOptionTab(self, name):
        instrument_tab = SpecOptionTabWidget(self.data_object, 'OPTIONS_BY_INSTRUMENT', name)
        self.tabWidget.addTab(instrument_tab, name)
        instrument_tab.tab_name = name
        instrument_tab.text_updater.connect(self.notesUpdate)
        return instrument_tab

    def getTabForName(self, name):
        for tab_index in range(1, self.tabWidget.count()):
            if self.tabWidget.widget(tab_index).tab_name == name:
                return self.tabWidget.widget(tab_index)
        return None

    def tabExists(self, name):
        for tab_index in range(1, self.tabWidget.count()):
            if self.tabWidget.widget(tab_index).tab_name == name:
                return True

        return False


    def fetchPositions(self):
        self.position_manager.retrievePositions()



class TabBarStyle(QtWidgets.QProxyStyle):


    def drawControl(self, element, option, painter, widget=None):
        icon = QtGui.QIcon()

        #logger.printLine("How far do we get?")
        
        if element == QtWidgets.QStyle.CE_TabBarTabLabel:
            icon = QtGui.QIcon(option.icon)
            # draw without icon
            option.icon = QtGui.QIcon()

        super(TabBarStyle, self).drawControl(element, option, painter, widget)

        if icon.isNull():
            return

        alignment = QtCore.Qt.AlignCenter | QtCore.Qt.TextShowMnemonic

        if not self.proxy().styleHint(QtWidgets.QStyle.SH_UnderlineShortcut, option, widget):
            alignment |= QtCore.Qt.TextHideMnemonic


        tab_rect = self.proxy().subElementRect(QtWidgets.QStyle.SE_TabBarTabText, option, widget)

        fm = QtGui.QFontMetrics(painter.font())
        iconRect = fm.boundingRect(option.text)
        iconSize = QtCore.QSize(option.iconSize)

        if not iconSize.isValid():
            iconExtent = self.proxy().pixelMetric(QtWidgets.QStyle.PM_SmallIconSize)
            iconSize = QtCore.QSize(iconExtent, iconExtent)
            tabIconSize = icon.actualSize(
                iconSize,
                QtGui.QIcon.Normal
                if (option.state & QtWidgets.QStyle.State_Enabled)
                else QtGui.QIcon.Disabled,
                QtGui.QIcon.On
                if (option.state & QtWidgets.QStyle.State_Selected)
                else QtGui.QIcon.Off,
            )
            # High-dpi icons do not need adjustment; make sure tabIconSize is not larger than iconSize
            iconSize = QtCore.QSize(
                min(tabIconSize.width(), iconSize.width()),
                min(tabIconSize.height(), iconSize.height()),
            )
        
        offset = 0
        
        tabIcon = icon.pixmap(
            widget.window().windowHandle() if widget else None,
            QSize(100,20),
            QtGui.QIcon.Normal
            if (option.state & QtWidgets.QStyle.State_Enabled)
            else QtGui.QIcon.Disabled,
            QtGui.QIcon.On
            if (option.state & QtWidgets.QStyle.State_Selected)
            else QtGui.QIcon.Off,
        )

        painter.drawPixmap(tab_rect.x()+10, tab_rect.y(), tabIcon)
        rect = option.rect.moveCenter(-50,0)
        painter.drawText(rect, QtCore.Qt.AlignCenter, option.text)

    def createRectPixmap(self, col=QtGui.QColor(240,50,50)):
        px = QtGui.QPixmap(40,20)
        px.fill(QtCore.Qt.transparent)
        pxSize = px.rect().adjusted(1,1,-1,-1)
        painter = QtGui.QPainter(px)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        painter.setBrush(col)
        painter.setPen(QtGui.QPen(QtGui.QColor(150,20,20), 1.25))
        painter.drawRect(pxSize)
        painter.end()
        return px

        #TODO this should be in super
    def accepts(self, value):
        return False


class MyTabBar(QTabBar):

    __coloredTabs = [0, 1,2,3]

    def paintEvent(self, event):
        #super().paintEvent(event)
        painter = QStylePainter(self)
        opt = QStyleOptionTab()

        for i in range(self.count()):
            self.initStyleOption(opt, i)
            if i in self.__coloredTabs:
                opt.palette.setColor(QPalette.Button, QColor("#ff9900"))

            painter.drawControl(QtWidgets.QStyle.CE_TabBarTabShape, opt)
            painter.drawControl(QtWidgets.QStyle.CE_TabBarTabLabel, opt)


if __name__ == "__main__":

    app = QtWidgets.QApplication(sys.argv)
    QtWidgets.QApplication.setStyle(QStyleFactory.create('Fusion'))
    app.aboutToQuit.connect(app.deleteLater)
    window = OptionPositions()
    window.show()
    app.exec_()



