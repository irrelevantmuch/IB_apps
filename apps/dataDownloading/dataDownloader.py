
# Copyright (c) 2024 Jelmer de Vries
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation in its latest version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.


# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'optionsGraph.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5.QtCore import Qt
from dataHandling.Constants import Constants
from .DataDownloaderWindow import DataDownloaderWindow

class DataDownloader(DataDownloaderWindow):

    current_contract = None

    def __init__(self, symbol_manager, history_manager):
        super().__init__()
        self.symbol_manager = symbol_manager
        self.symbol_manager.api_updater.connect(self.apiUpdate, Qt.QueuedConnection)
        self.history_manager = history_manager
        self.history_manager.addNewListener(self, self.apiUpdate)


    def selectedContract(self, contractDetails):
        self.current_contract = contractDetails

    def returnSelection(self):
        pass


    def fetchHistoricalData(self):
        start_date = self.start_date_widget.selectedDate().toPyDate()
        end_date = self.end_date_widget.selectedDate().toPyDate()

        if self.current_contract is not None:
            self.history_manager.fetchBarsForSpecs(self.current_contract, start_date, end_date, self.bar_combobox.currentText())

    @pyqtSlot(str, dict)
    def apiUpdate(self, signal, sub_signal):
        super().apiUpdate(signal, sub_signal)

        if signal == Constants.HISTORICAL_DATA_FETCH_COMPLETE:
            self.saveData()


    def saveData(self, separately=False):
        self.history_manager.historicalDF.sort_index(inplace=True)
        file_name = './data/downloads/' + self.current_contract.symbol + '_daily.csv'
        self.history_manager.historicalDF.to_csv(file_name)

        #TODO this should be in super
    def accepts(self, value):
        return False

        