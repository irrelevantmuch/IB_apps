
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'optionsGraph.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5 import QtCore #, QtWidgets, QtGui
from PyQt5.QtCore import Qt, QThread, pyqtSignal, pyqtSlot
from dataHandling.HistoryManagement.HistoricalDataManagement import HistoricalDataManager
from dataHandling.HistoryManagement.FinazonDataManager import FinazonDataManager
from dataHandling.Constants import Constants, DT_BAR_TYPES
from .AlertWindow import AlertWindow

from PyQt5.QtWidgets import QMainWindow
from TelegramBot import TelegramBot
import json
import requests

import re

from .AlertProcessor import AlertProcessorFinazon, AlertProcessorIB
from dataHandling.UserDataManagement import getStockListNames, readStockList
from dataHandling.HistoryManagement.BufferedManager import BufferedDataManager

from itertools import cycle


class AlertManager(AlertWindow):

    selection_signal_change = pyqtSignal(str, dict)
    threshold_signal_change = pyqtSignal(str, dict)
    update_signal = pyqtSignal(bool)
    list_addition_signal = pyqtSignal(str)
    list_removal_signal = pyqtSignal(str)
    alerting_signal = pyqtSignal(bool)

    telegram_signal = pyqtSignal(str, float, dict, float)

    updating = False
    message_listening = False
    last_update_id = 0
    

    def __init__(self, history_manager, indicator_processor):
        super().__init__()

        history_manager.api_updater.connect(self.apiUpdate, Qt.QueuedConnection)

        self.setupTelegramBot()
        self.loadLists()
        file_name, _ = self.stock_lists[0]
        self.history_manager = history_manager
        self.prepAlertProcessor(history_manager, indicator_processor)
        self.setDefaultThresholds()


    def setDefaultThresholds(self):
        self.lower_spin_all.setValue(30)
        self.higher_spin_all.setValue(70)
        self.up_spin_all.setValue(6)
        self.down_spin_all.setValue(6)

        self.up_check_all.setChecked(True)
        self.down_check_all.setChecked(True)
        self.reversal_box_all.setChecked(True)
        self.cross_box_all.setChecked(True)


    def setupTelegramBot(self):
                # Setup the bot logic and thread
        self.telegram_bot = TelegramBot()  # Replace with your actual token
        # self.bot_thread = QThread()
        
        self.telegram_signal.connect(self.telegram_bot.sendMessage, Qt.QueuedConnection)
        # self.telegram_bot.moveToThread(self.bot_thread)
        # self.bot_thread.started.connect(self.telegram_bot.run)
        # self.bot_thread.start()


    def prepAlertProcessor(self, history_manager, indicator_processor):
        if isinstance(history_manager, FinazonDataManager):
            self.alert_processor = AlertProcessorFinazon(history_manager, indicator_processor, self.telegram_signal)
        elif isinstance(history_manager, HistoricalDataManager):
            self.alert_processor = AlertProcessorIB(history_manager, indicator_processor, self.telegram_signal)
        self.processor_thread = QThread()
        self.alert_processor.moveToThread(self.processor_thread)
        
        self.update_signal.connect(self.alert_processor.runUpdates, Qt.QueuedConnection)
        self.list_addition_signal.connect(self.alert_processor.addStockList, Qt.QueuedConnection)
        self.list_removal_signal.connect(self.alert_processor.removeStockList, Qt.QueuedConnection)
        self.alerting_signal.connect(self.alert_processor.toggleAlerts, Qt.QueuedConnection)
        self.alert_processor.stock_count_signal.connect(self.stockCountUpdated, Qt.QueuedConnection)
        self.selection_signal_change.connect(self.alert_processor.selectionSignalChange, Qt.QueuedConnection)
        self.threshold_signal_change.connect(self.alert_processor.thresholdChangeSignal, Qt.QueuedConnection)

        self.processor_thread.started.connect(self.alert_processor.run)
        self.processor_thread.start()
        self.processor_thread.setPriority(QThread.HighestPriority)

        self.signalAlertPreferences()


    def signalAlertPreferences(self):
        self.updateCheckListFor("cross_box", "cross_checks")
        self.updateCheckListFor("reversal_box", "reversal_checks")
        self.updateCheckListFor("up_check", "up_checks")
        self.updateCheckListFor("down_check", "down_checks")
        self.updateThresholds("lower_spin", "cross_down_threshold")
        self.updateThresholds("higher_spin", "cross_up_threshold")
        self.updateThresholds("down_spin", "step_down_threshold")
        self.updateThresholds("up_spin", "step_up_threshold")


    def startUpdating(self):
        if not self.updating:
            self.updating = True
            # self.history_manager.lockForCentralUpdating(self)
            self.comp_checkable_lists.disableSelection()
            self.list_selection_button.setEnabled(False)
            self.rotation_button.setText("Stop Updates")
            self.update_signal.emit(True)
        else:
            self.update_signal.emit(False)
            self.comp_checkable_lists.enableSelection()
            # self.history_manager.unlockCentralUpdating()
            self.list_selection_button.setEnabled(True)
            self.rotation_button.setText("Rotating Updates")

            self.updating = False


    def loadLists(self):
        
        self.stock_lists = getStockListNames()

        self.comp_checkable_lists.blockSignals(True)

        file_list = dict()

        for index, (file_name, list_name) in enumerate(self.stock_lists):

            file_list[index] = file_name
            self.comp_checkable_lists.key_list = file_list
            self.comp_checkable_lists.addItem(list_name)

            item = self.comp_checkable_lists.model().item(index, 0)
            item.setCheckState(QtCore.Qt.Unchecked)

        self.comp_checkable_lists.blockSignals(False)            

    
    def toggleDataListening(self, value):
        self.alerting_signal.emit(value)

    
    def stockCountUpdated(self, value):
        self.stock_count_label.setText(str(value))


    def updateCheckListFor(self, button_name, signal_type):
        check_list = dict()
        for tf in self.time_frame_names:
            if tf != 'all':
                check_list[self.bar_type_conv[tf]] = self.widgetFor(f"{button_name}_{tf}").isChecked()
        self.selection_signal_change.emit(signal_type, check_list)


    def updateThresholds(self, button_name, signal_type):
        threshold_list = dict()
        for tf in self.time_frame_names:
            if tf != 'all':
                threshold_list[self.bar_type_conv[tf]] = self.widgetFor(f"{button_name}_{tf}").value()
        self.threshold_signal_change.emit(signal_type, threshold_list)


    def closeEvent(self, *args, **kwargs):
        
        self.alert_processor.deleteLater()
        self.processor_thread.quit()
        self.processor_thread.wait()
        super(QMainWindow, self).closeEvent(*args, **kwargs)


    def listSelection(self, value):
        toggle, list_name = self.comp_checkable_lists.getSelectionAt(value)
        if toggle:
            self.list_addition_signal.emit(list_name)
        else:
            self.list_removal_signal.emit(list_name)


    def toggleSelection(self):
        if self.list_selection_button.text() == "All Off":
            self.list_selection_button.setText("All On")
            self.comp_checkable_lists.deselectAll()
        else:
            self.list_selection_button.setText("All Off")
            self.comp_checkable_lists.selectAll()


    def getStockList(self, for_index):            
        file_name, _ = self.stock_lists[for_index]


    def parseCommands(self, message):
        token_list = re.split("[., !?:()]+", message)
        print(token_list)
        command = token_list[0]
        param_dict = dict()
        for token in token_list[1:]:
            param = re.split("=", token)
            print(param)
            param_dict[param[0]] = param[1]
        return command, param_dict


    @pyqtSlot(str, dict)
    def apiUpdate(self, signal, sub_signal):
        pass
        #super().apiUpdate(signal, sub_signal)
        # print(f"AlertManager.apiUpdate {signal}")
        # if signal == Constants.HISTORICAL_UPDATE_COMPLETE or signal == Constants.HISTORICAL_REQUESTS_COMPLETED:
        #     if self.rotating:
        #         self.fetchNextList()


    def accepts(self, value):
        return False


    # def sendPhoto(self, file_name):
    #     method = 'sendPhoto'
    #     params = {'chat_id': self.bot_info['chat_id']}
    #     files = {'photo': file_name}
    #     api_url = f"https://api.telegram.org/bot{self.bot_info['token']}/"
    #     resp = requests.post(api_url + method, params, files=files)
    #     return resp


    