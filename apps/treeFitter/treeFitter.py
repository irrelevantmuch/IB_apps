# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'optionsGraph.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5.QtCore import Qt, pyqtSlot
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QMainWindow, QCompleter, QTableWidgetItem
import numpy as np
from dataHandling.Constants import Constants
from .TreeFitterWindow import TreeFitterWindow
from .FeatureParser import FeatureParser
from .TreeTraining import TreeTraining

import sys, threading

from ibapi.order import Order
from ibapi.contract import Contract

import pandas as pd
from datetime import datetime
from pytz import timezone
from dateutil.relativedelta import relativedelta
from PyQt5.QtWidgets import QCompleter

from uiComps.generalUIFunctionality import addCheckableTickersTo

from generalFunctionality.GenFunctions import addRSIsEMAs

from dataHandling.HistoryManagement.BufferedManager import BufferedDataManager
from dataHandling.SymbolManager import SymbolDataManager
from dataHandling.HistoryManagement.HistoricalDataManagement import HistoricalDataManager
from dataHandling.TradeManagement.UserDataManagement import readStockList


#- stairstep efficienter maken

#- model gebruiken voor voorspelling
#- voorspelling quartilizeren of classificeren
#- meer features



class TreeFitter(TreeFitterWindow):
	
	history_len = 0
	is_initial_fetch = True
	trade_on = False
	bar_type = '5 mins'

	stair_steps = False
	inside_bars = False
	rsi_reversals = False


	stock_rsi_on = True
	sector_rsi_on = True
	volatility_rsi_on = True
	stock_move_on = True

	strategy_types = [Constants.UP_STEPS, Constants.DOWN_STEPS, Constants.BULL_BARS, Constants.BEAR_BARS,Constants.TOP_REVERSAL, Constants.BOTTOM_REVERSAL]


	def __init__(self):
		super().__init__()

		self.loadNewStockList(0, assign_to_all=False)

		self.feature_parser = FeatureParser()
		self.tree_training = TreeTraining()

		self.bar_selector.setCurrentText(self.bar_type)


	def generateFrames(self):
		for uid in self.stock_list.keys():
			existing_buffers = self.loadBuffers(uid, bar_types=[self.bar_type, '1 min'])
			print(f"We go for {uid}")
			
			if self.stair_steps:
				print('We create stairstep frames')
				self.feature_parser.generateStairSteps(uid, existing_buffers)
			if self.inside_bars:
				print('We create iniside bar frames')
				self.feature_parser.generateInsideBars(uid, existing_buffers)
			if self.rsi_reversals:
				print('We create rsi reversal frames')
				self.feature_parser.generateRsiReversals(uid, existing_buffers)
		print(f"We generated data frames")


	def addFeatures(self): 
		sector_buffers, sector_list = self.loadSectorBuffers()

		for uid in self.stock_list.keys():
			print(f"We add features for {self.stock_list[uid][Constants.SYMBOL]} ({uid})")
			buffers = self.loadBuffers(uid, bar_types=[self.bar_type, '1 min', '1 hour', '1 day'])
			feature_selection = [self.stock_rsi_on, self.sector_rsi_on, self.volatility_rsi_on, self.stock_move_on]
			self.feature_parser.addFeatures(uid, buffers, sector_buffers, sector_list, feature_selection)
		print("We added the features")


	def saveFrames(self):
		file_name, description = self.stock_lists[self.stock_list_index]
		self.feature_parser.saveData()
		print(f"We saved the frames")


	def loadFrames(self):
		strategies = []
		if self.stair_steps: strategies += [Constants.UP_STEPS, Constants.DOWN_STEPS]
		if self.inside_bars: strategies += [Constants.BULL_BARS, Constants.BEAR_BARS]
		if self.rsi_reversals: strategies += [Constants.TOP_REVERSAL, Constants.BOTTOM_REVERSAL]
		self.feature_parser.loadData(self.stock_list, strategies)
		print("We loaded the frames")


	def trainData(self):
		if self.stair_steps:
			up_frame, down_frame = self.feature_parser.getStepFrames()
			self.tree_training.runTrainTestLoop(up_frame, Constants.UP_STEPS)
			self.tree_training.runTrainTestLoop(down_frame, Constants.DOWN_STEPS)

		if self.inside_bars:
			bull_bars, bear_bars = self.feature_parser.getInsideFrames()
			self.tree_training.runTrainTestLoop(bull_bars, Constants.BULL_BARS)
			self.tree_training.runTrainTestLoop(bear_bars, Constants.BEAR_BARS)

		if self.rsi_reversals:
			top_reversal, bottom_reversal = self.feature_parser.getReversalFrames()
			self.tree_training.runTrainTestLoop(top_reversal, Constants.TOP_REVERSAL)
			self.tree_training.runTrainTestLoop(bottom_reversal, Constants.BOTTOM_REVERSAL)

		print(f"We trained the trees")


	def resetTickerList(self):
		print('resetTickerList')
		self.checkable_ticker_box.blockSignals(True)
		self.checkable_ticker_box.clear()
		self.check_list = self.generateCheckList(self.stock_list)
		addCheckableTickersTo(self.checkable_ticker_box, self.stock_list, self.check_list)
		self.checkable_ticker_box.blockSignals(False)


	def tickerListClicked(self, value):
		self.check_list.update(self.checkable_ticker_box.itemStates())
		self.updateStocklists()

		
	def tickerSelectionToggle(self):
		print(f"Do we toggle? {self.checkable_ticker_box.noItemsSelected()} {self.checkable_ticker_box.allItemsSelected()}")
		if self.checkable_ticker_box.noItemsSelected():
			self.checkable_ticker_box.selectAll()
			self.sel_all_button.setText("Uncheck All")
		elif self.checkable_ticker_box.allItemsSelected():
			self.checkable_ticker_box.deselectAll()
			self.sel_all_button.setText("Check All")
		self.check_list.update(self.checkable_ticker_box.itemStates())
		self.updateStocklists()
		

	def updateStocklists(self):
		stock_list = self.getActiveTickerList()


	def getActiveTickerList(self):
		return {stock_id: self.stock_list[stock_id] for stock_id, checked in self.check_list.items() if checked}


	def generateCheckList(self, stock_list):
		return {k: True for k in stock_list}


	def getStockList(self, for_index):            
			file_name, _ = self.stock_lists[for_index]

			if file_name is not None:
				return readStockList(file_name)
			
			return []

	def findSectorList(self):
		for (file_name, list_name) in self.stock_lists:
			if list_name == 'Sectors':
				return file_name

		return None


	def stockRSICheck(self, value):
		self.stock_rsi_on = value
	

	def sectorRSICheck(self, value):
		self.sector_rsi_on = value
			

	def volatilityCheck(self, value):
		self.volatility_rsi_on = value
	

	def moveCheck(self, value):
		self.stock_move_on = value


	def loadSectorBuffers(self, bar_types=['1 day']):
		sector_filename = self.findSectorList()
		if sector_filename is not None:
			sector_list = readStockList(sector_filename)
		
		sector_buffers = dict()
		for uid in sector_list.keys():
			for bar_type in bar_types:
				sector_buffers[uid, bar_type] = self.loadExistingBuffer(uid, bar_type)

		return sector_buffers, sector_list


	def loadBuffers(self, uid, bar_types=['1 min', '5 mins', '15 mins']):
		existing_buffers = dict()
		
		for bar_type in bar_types:
			existing_buffers[bar_type] = self.loadExistingBuffer(uid, bar_type)

		return existing_buffers


	def loadExistingBuffer(self, uid, bar_type):

		try:
			file_name = Constants.POLYGON_BUFFER_FOLDER + uid + '_' + bar_type + '.pkl'
			buffer = pd.read_pickle(file_name)
			buffer = addRSIsEMAs(buffer)
			return buffer
		except Exception as inst:
			print(f"Cannot load {uid} due to: {inst}")

		return None

	def saveTrainedTrees(self):
		self.tree_training.saveTreeModels()


	def loadNewStockList(self, index, assign_to_all=True):
		print('loadNewStockList')
		self.stock_list = self.getStockList(index)
		self.stock_list_index = index
		self.resetTickerList()


	
	def selectBarType(self, value):
		print(f"We set the bar_type to: {value}")
		self.bar_type = value
		self.feature_parser.setTargetBartype(value)


	def rsirevCheck(self, value):
		self.rsi_reversals = value
		
	def stairCheck(self, value):
		self.stair_steps = value
		
	def insideCheck(self, value):
		self.inside_bars = value


	def tickerSelection(self, value):
		pass        


		#TODO this should be in super
	def accepts(self, value):
		return False


	def closeEvent(self, *args, **kwargs):
		super(QMainWindow, self).closeEvent(*args, **kwargs)


