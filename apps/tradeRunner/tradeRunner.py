# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'optionsGraph.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5.QtCore import Qt, pyqtSlot
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QMainWindow, QCompleter, QTableWidgetItem
import numpy as np
from dataHandling.Constants import Constants
from .TradeRunnerWindow import TradeRunnerWindow
from .LiveBufferManager import LiveBufferManager
from dataHandling.HistoryManagement.BufferedManager import BufferedDataManager
from .StairStrategy import StairStrategy
import sys, threading

from ibapi.order import Order
from ibapi.contract import Contract

import pandas as pd
from datetime import datetime
from pytz import timezone
from dateutil.relativedelta import relativedelta
from PyQt5.QtWidgets import QCompleter

from uiComps.generalUIFunctionality import addCheckableTickersTo

from dataHandling.SymbolManager import SymbolDataManager
from dataHandling.HistoryManagement.HistoricalDataManagement import HistoricalDataManager
from dataHandling.TradeManagement.UserDataManagement import readStockList

class TradeRunner(TradeRunnerWindow):
    
    history_len = 0
    is_initial_fetch = True
    trade_on = False
    bar_type = '5 mins'

    # action_type = "BUY"

    # stop_limit_on = False
    # stop_loss_on = False
    # profit_take_on = False


    def __init__(self, order_manager, history_manager):
        super().__init__()
        #self.loadData()
        self.order_manager = order_manager
        self.history_manager = history_manager

        self.loadNewStockList(0, assign_to_all=False)
        
        self.history_manager.api_updater.connect(self.apiUpdate)
        self.live_datamanager = LiveBufferManager(history_manager, self.stock_list)
        self.strategy_trader = StairStrategy(self.order_manager, self.live_datamanager, self.stock_list)

        self.bar_selector.setCurrentText(self.bar_type)


    def barSelection(self, value):
        self.bar_type = self.bar_types[value]


    def toggleLiveData(self):
        if self.data_toggle_button.text() == "Track Data!":
            self.data_toggle_button.setText("Stop Data Feed")
            self.live_datamanager.requestUpdates(self.bar_type)

        else:
            self.data_toggle_button.setText("Track Data!")


    def toggleTrading(self):
        if self.trade_toggle_button.text() == "Trade!":
            
            self.setPanelEnabled(False)
            self.trade_on = True
            self.trade_toggle_button.setText("Stop!")
        else:
            self.setPanelEnabled(True)
            self.trade_on = True
            self.trade_toggle_button.setText("Trade!")


    def setPanelEnabled(self, value):
        self.data_toggle_button.setEnabled(value)
        self.checkable_ticker_box.setEnabled(value)
        self.sel_all_button.setEnabled(value)
        self.list_selector.setEnabled(value)
        

    def resetTickerList(self):
        print('resetTickerList')
        self.checkable_ticker_box.blockSignals(True)
        self.checkable_ticker_box.clear()
        self.check_list = self.generateCheckList(self.stock_list)
        addCheckableTickersTo(self.checkable_ticker_box, self.stock_list, self.check_list)
        self.checkable_ticker_box.blockSignals(False)


    def tickerListClicked(self, value):
        self.check_list.update(self.checkable_ticker_box.itemStates())
        self.updateStocklists()

        
    def tickerSelectionToggle(self):
        print(f"Do we toggle? {self.checkable_ticker_box.noItemsSelected()} {self.checkable_ticker_box.allItemsSelected()}")
        if self.checkable_ticker_box.noItemsSelected():
            self.checkable_ticker_box.selectAll()
            self.sel_all_button.setText("Uncheck All")
        elif self.checkable_ticker_box.allItemsSelected():
            self.checkable_ticker_box.deselectAll()
            self.sel_all_button.setText("Check All")
        self.check_list.update(self.checkable_ticker_box.itemStates())
        self.updateStocklists()
        

    def updateStocklists(self):
        print("Does this fix it?")
        print(self.getActiveTickerList())
        stock_list = self.getActiveTickerList()
        self.strategy_trader.stock_list = stock_list
        self.live_datamanager.stock_list = stock_list


    def loadModels(self):
        for strategy in self.strategy_types:
            if self.strategy_checked[strategy]:
                try:
                    model_file = Constants.ANAYLIS_RESULTS_FOLDER + 'models/xgbclassifier_' + strategy + '.pkl', 'wb'
                    self.tree_models[strategy] = pd.read_pickle(model_file)
                except:
                    print(f"Can't load strategy")
            

    def getActiveTickerList(self):
        return {stock_id: self.stock_list[stock_id] for stock_id, checked in self.check_list.items() if checked}


    def generateCheckList(self, stock_list):
        return {k: True for k in stock_list}


    def getStockList(self, for_index):            
            file_name, _ = self.stock_lists[for_index]

            if file_name is not None:
                return readStockList(file_name)
            
            return []


    def loadNewStockList(self, index, assign_to_all=True):
        print('loadNewStockList')
        self.stock_list = self.getStockList(index)

        if assign_to_all:
            self.strategy_trader.stock_list = self.stock_list
            self.live_datamanager.setStockList(self.stock_list)
        self.resetTickerList()


    def tickerSelection(self, value):
        pass        

    @pyqtSlot(str, dict)
    def apiUpdate(self, signal, sub_signal):
        #        self.strategy_trader.performPreprocessing(stock_buffers, sector_buffers, sector_list)

        if self.live_datamanager.live_data_on:
            if signal == Constants.HISTORICAL_UPDATE_COMPLETE:
                print("DATA COLLECTION UP AND RUNNING")
                if self.is_initial_fetch:
                    self.is_initial_fetch = False
                self.strategy_trader.performLiveProcessing([])
                self.trade_toggle_button.setEnabled(True)
                    
            elif signal == Constants.HISTORICAL_REQUEST_COMPLETED:
                if not self.is_initial_fetch:
                    self.strategy_trader.performLiveProcessing([], keys=[sub_signal['key']])
                    if self.trade_on: self.strategy_trader.makeTrades()
        else:
            if signal == Constants.HISTORICAL_REQUESTS_COMPLETED or signal == Constants.HISTORICAL_UPDATE_COMPLETE:
                for key in self.live_datamanager.existing_buffers:
                    print(f"{key}: {len(self.live_datamanager.existing_buffers[key])}")
            

    def strategyPreprocessing(self, buffers):
        self.strategy_processor.process_data(self.short_term_buffers)


    def strategyExecution(self, buffers):
        self.strategy_trader.process_data(self.short_term_buffers)


    def performPreprocessing(self):
        
        # sector_filename = self.findSectorList()
        # print(f"Are we getting it here {sector_filename}")
        # if sector_filename is not None:
        #     sector_list = readStockList(sector_filename)
        #     self.live_datamanager.addStocksToBufferList(sector_list)

        self.live_datamanager.fetchLatestStockData()


    def findSectorList(self):
        for (file_name, list_name) in self.stock_lists:
            if list_name == 'Sectors':
                return file_name

        return None


#stock_buffers = self.loadStockBuffers()
        #sector_buffers, sector_list = self.loadSectorBuffers()


    # def loadStockBuffers(self, bar_types=['1 day']):
    #     stock_buffers = dict()
    #     for uid in self.stock_list.keys():
    #         for bar_type in bar_types:
    #             stock_buffers[uid, bar_type] = self.loadExistingBuffer(uid, bar_type)

    #     return stock_buffers


    # def loadSectorBuffers(self, bar_types=['1 day']):
    #     sector_filename = self.findSectorList()
    #     if sector_filename is not None:
    #         sector_list = readStockList(sector_filename)
        
    #     sector_buffers = dict()
    #     for uid in sector_list.keys():
    #         for bar_type in bar_types:
    #             sector_buffers[uid, bar_type] = self.loadExistingBuffer(uid, bar_type)

    #     return sector_buffers, sector_list


    # def loadBuffers(self, uid, bar_types=['1 min', '5 mins', '15 mins']):
    #     existing_buffers = dict()
        
    #     for bar_type in bar_types:
    #         existing_buffers[bar_type] = self.loadExistingBuffer(uid, bar_type)

    #     return existing_buffers


    # def loadExistingBuffer(self, uid, bar_type):

    #     try:
    #         file_name = Constants.POLYGON_BUFFER_FOLDER + uid + '_' + bar_type + '.pkl'
    #         buffer = pd.read_pickle(file_name)
    #         buffer = addRSIsEMAs(buffer)
    #         return buffer
    #     except Exception as inst:
    #         print(f"Cannot load {uid} due to: {inst}")

    #     return None


    # def getCurrentContract(self):
    #     pass
        # contract = Contract()
        # contract.symbol = self.stock_list[self.selected_key][Constants.SYMBOL]
        # contract.secType = Constants.STOCK
        # contract.conId = self.selected_key
        # contract.exchange = "SMART"
        # return contract


    # def placeOrder(self):
        # pass
        # action = self.action_type
        # contract = self.getCurrentContract()
        # id_count = 1
        # if self.stop_loss_on: id_count += 1
        # if self.profit_take_on: id_count += 1
        # order_ids = self.trade_manager.getNextOrderIDs(count=id_count)

        # quantity = self.count_field.value()
        # limit_price = self.limit_field.text()

        # primary_id = order_ids.pop(0)
        # order_set = [self.createBaseOrder(primary_id, action, quantity, limit_price)]

        # if self.profit_take_on:
        #     profit_take = self.profit_take_field.text()

        #     order_set += [self.createProfitTake(order_ids.pop(0), action, quantity, profit_take, primary_id)]


        # if self.stop_loss_on:
        #     stop_trigger = self.stop_trigger_field.text()
        #     stop_limit = self.stop_limit_field.text()

        #     if self.stop_limit_on:
        #         order_set += [self.createStopOrder(order_ids.pop(0), action, quantity, stop_trigger, primary_id, stop_limit=stop_limit)]
        #     else:
        #         order_set += [self.createStopOrder(order_ids.pop(0), action, quantity, stop_trigger, primary_id, stop_limit=None)]
        

        # for order in order_set: 
        #     print(f"{order.orderId}: {order.action}, {order.orderType}")
        # order_set[-1].transmit = True

        # last_order = order_set[-1]
        # print(f"{last_order.orderId}: {last_order.action}, {last_order.orderType}")
        
        # self.trade_manager.placeBracketOrder(order_set, contract)



    # def createBaseOrder(self, order_id, action, quantity, limit_price):
    #         #This will be our main or "parent" order
    #     base_order = Order()
    #     base_order.orderId = order_id
    #     base_order.action = action
    #     base_order.orderType = "LMT"
    #     base_order.totalQuantity = quantity
    #     base_order.lmtPrice = limit_price
    #     base_order.eTradeOnly = ''
    #     base_order.firmQuoteOnly = ''
    #     #The parent and children orders will need this attribute set to False to prevent accidental executions.
    #     #The LAST CHILD will have it set to True, 
    #     base_order.transmit = False
    #     return base_order


    # def createProfitTake(self, order_id, base_action, quantity, limit_price, parent_id):
    #     take_profit = Order()
    #     take_profit.orderId = order_id
    #     take_profit.action = "SELL" if base_action == "BUY" else "BUY"
    #     take_profit.orderType = "LMT"
    #     take_profit.totalQuantity = quantity
    #     take_profit.lmtPrice = limit_price
    #     take_profit.parentId = parent_id
    #     take_profit.eTradeOnly = ''
    #     take_profit.firmQuoteOnly = ''
        
    #     take_profit.transmit = False
    #     return take_profit


    # def createStopOrder(self, order_id, base_action, quantity, stop_price, parent_id, stop_limit=None):
    #     stop_loss = Order()
    #     stop_loss.orderId = order_id
    #     stop_loss.action = "SELL" if base_action == "BUY" else "BUY"
    #     if stop_limit is not None:
    #         stop_loss.orderType = "STP LMT"
    #         stop_loss.lmtPrice = stop_limit
    #     else:
    #         stop_loss.orderType = "STP"
    #     stop_loss.auxPrice = stop_price
    #     stop_loss.totalQuantity = quantity
    #     stop_loss.parentId = parent_id
    #     #In this case, the low side order will be the last child being sent. Therefore, it needs to set this attribute to True 
    #     #to activate all its predecessors
    #     stop_loss.eTradeOnly = ''
    #     stop_loss.firmQuoteOnly = ''
        
    #     stop_loss.transmit = False
    #     return stop_loss


    # def getCurrentBars(self, starting_bar=0):
    #     return self.buffered_manager.existing_buffers[self.selected_key, Constants.FIVE_MIN_BAR].iloc[starting_bar:]


#     def fillOutPriceFields(self):
#         latest_bar = self.getCurrentBars(-1)
#         latest_price = latest_bar[Constants.CLOSE]
#         self.limit_field.setValue(latest_price)
#         if self.action_type == "BUY":
#             price_offset = 1
#         else:
#             price_offset = -1
        
#         self.profit_take_field.setValue(latest_price+price_offset)
#         self.stop_trigger_field.setValue(latest_price-price_offset)
#         self.stop_limit_field.setValue(latest_price-(price_offset*1.1))
        

#     def buySellSelection(self, button):
#         if button == self.buy_field:
#             self.action_type = "BUY"
#             self.submit_button.setText("Buy")
#             palette = self.submit_button.palette()

#             palette.setColor(QtGui.QPalette.Button, QtGui.QColor('orange'))
#             self.submit_button.setAutoFillBackground(True)
#             self.submit_button.setPalette(palette)
# #            self.submit_button.setStyleSheet(" border-style: outset; border-width: 2px; border-radius: 15px; border-color: black; padding: 0px; background-color: rgb(20, 255, 55);")

#         elif button == self.sell_field:
#             self.action_type = "SELL"
#             self.submit_button.setText("Sell")
#  #           self.submit_button.setStyleSheet("background-color: rgb(255, 25, 55);")


#     def stopLimitCheck(self, value):
#         self.stop_limit_on = value

#         if self.stop_limit_on:
#             self.stop_loss_on = True
#             self.stop_loss_check.setChecked(self.stop_loss_on)

#     def stoplossCheck(self, value):
#         self.stop_loss_on = value

#         if not self.stop_loss_on:
#             self.stop_limit_on = False
#             self.stop_limit_check.setChecked(self.stop_limit_on)


    def profitTakeCheck(self, value):
        print("This is not just a bool")
        print(value)
        print(type(value))
        self.profit_take_on = value


        #TODO this should be in super
    def accepts(self, value):
        return False


    def closeEvent(self, *args, **kwargs):
        super(QMainWindow, self).closeEvent(*args, **kwargs)


