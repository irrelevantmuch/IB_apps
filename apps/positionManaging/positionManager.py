
# Copyright (c) 2024 Jelmer de Vries
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation in its latest version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'optionsGraph.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5.QtCore import Qt, pyqtSlot, pyqtSignal, QThread
from PyQt5.QtWidgets import QMainWindow, QAbstractButton, QTableView
from dataHandling.Constants import Constants
from .OrderDataModel import OrderDataModel, StairDataModel, SpinBoxDelegate, ButtonDelegate, CheckBoxDelegate
from .PositionWindow import PositionWindow
from dataHandling.TradeManagement.PositionDataManagement import PositionDataModel

from ibapi.contract import Contract

from .TickerProcessor import LiveTickerProcessor

from dataHandling.UserDataManagement import readStockList, getStockListNames


class PositionApp(PositionWindow):

    cancel_all_signal = pyqtSignal()
    cancel_order_by_row = pyqtSignal(int)
    cancel_stair_by_row = pyqtSignal(int)
    

    def __init__(self, position_manager, order_manager):
        super().__init__()

        self.position_manager = position_manager
        self.order_manager = order_manager

        self.order_buffer = self.order_manager.getOrderBuffer()
        self.setupOrderTable(self.order_buffer)
        self.setupPositionTable()
        
        self.connectSignalSlots()


    @pyqtSlot(str, dict)
    def positionUpdate(self, signal, sub_signal):
        pass


    def setupPositionTable(self):
        self.data_object = self.position_manager.getDataObject()
        self.data_object.position_signal.connect(self.positionUpdate, Qt.QueuedConnection)
        self.position_model = PositionDataModel(self.data_object, 'ALL', None)
        self.position_table.setModel(self.position_model)
        self.position_table.setSortingEnabled(True)


    def setupOrderTable(self, order_buffer):
        column_headers = ['Order ID', 'Symbol', 'Action', 'Count', 'Limit', 'Stop level', 'Status']
        self.int_spin_box_delegate = SpinBoxDelegate('int_spin_box')
        self.double_spin_box_delegate = SpinBoxDelegate('double_spin_box')
        self.order_table.setItemDelegateForColumn(column_headers.index('Count'), self.int_spin_box_delegate)
        self.order_table.setItemDelegateForColumn(column_headers.index('Limit'), self.double_spin_box_delegate)
        self.order_table.setItemDelegateForColumn(column_headers.index('Stop level'), self.double_spin_box_delegate)
        
        self.cancel_delegate = ButtonDelegate('Cancel' ,self.order_table)
        self.cancel_delegate.button_click_signal.connect(self.cancelOrderByRow)
        self.order_table.setItemDelegateForColumn(len(column_headers), self.cancel_delegate)

        self.order_model = OrderDataModel(order_buffer, column_headers)
        self.order_model.order_edit_update.connect(self.order_manager.orderEdit, Qt.QueuedConnection)
        self.order_table.setModel(self.order_model)


    def connectSignalSlots(self):
        self.cancel_all_signal.connect(self.order_manager.cancelAllOrders, Qt.QueuedConnection)
        self.cancel_order_by_row.connect(self.order_manager.cancelOrderByRow, Qt.QueuedConnection)
        # self.cancel_stair_by_row.connect(self.order_manager.cancelStairByRow, Qt.QueuedConnection)
        # self.kill_stair_order.connect(self.order_manager.killStairTrade, Qt.QueuedConnection)
        

    # @pyqtSlot(str, dict)
    # def dataUpdate(self, signal, sub_signal):
    #     if (self.selected_key == sub_signal['uid']) and (self.selected_bar_type in sub_signal['bars']):
    #         if signal == Constants.HISTORICAL_DATA_READY:
    #             if self.data_buffers.bufferExists(self.selected_key, self.selected_bar_type):
    #                 bars = self.data_buffers.getBufferFor(self.selected_key, self.selected_bar_type)

    #                 if self.tab_widget.tabText(self.tab_widget.currentIndex()) == "Stairstep":
    #                     self.checkIfStairTradable(bars.iloc[-2])

    #                 self.trade_plot.setHistoricalData(bars.iloc[:-1])
    #                 self.trade_plot.addNewBars(bars.iloc[[-1]], bars.index[-1])
    #                 if self.fields_need_updating:
    #                     self.fillOutPriceFields(include_profit_loss=True)
    #                     self.fields_need_updating = False
    #         elif signal == Constants.HAS_NEW_DATA:
    #             if self.data_buffers.bufferExists(self.selected_key, self.selected_bar_type):
    #                 if self.selected_bar_type in sub_signal['updated_from']:
    #                     from_index = sub_signal['updated_from'][self.selected_bar_type]
    #                     bars = self.data_buffers.getBarsFromLabelIndex(self.selected_key, self.selected_bar_type, from_index)
    #                     self.trade_plot.addNewBars(bars, from_index)



    def cancelOrderByRow(self, row_index):
        self.cancel_order_by_row.emit(row_index)



    # @pyqtSlot(str, dict)
    # def trackingUpdate(self, signal, sub_signal):
    #     if signal == "Stair Opened":
    #         self.step_button.setText("Cancel Track")
    #         self.is_tracking_steps = True
    #     elif signal == "Stair Killed":
    #         self.step_button.setText("Open Stair")
    #         self.is_tracking_steps = False



    def cancelAllTrades(self):
        self.cancel_all_signal.emit()


    
###################### level autosetting

    def setLevelsFromChart(self, high_low, price_level):

        price_margin = 0.1
        tab_name = self.tab_widget.tabText(self.tab_widget.currentIndex())

        print(f"TradeMaker.setLevels for {tab_name}")

        if tab_name == "General Order":
            if self.action_type == Constants.BUY and high_low == Constants.HIGH:
                self.profit_limit_field.setValue(price_level)
                self.profit_take_check.setChecked(True)
            elif self.action_type == Constants.BUY and high_low == Constants.LOW:
                self.stop_trigger_field.setValue(price_level-price_margin)
                self.stop_limit_field.setValue(price_level-(price_margin*2))
                self.stop_loss_check.setChecked(True)
                self.stop_limit_check.setChecked(True)
            elif self.action_type == Constants.SELL and high_low == Constants.HIGH:
                self.stop_trigger_field.setValue(price_level+price_margin)
                self.stop_limit_field.setValue(price_level+(price_margin*2))
                self.stop_loss_check.setChecked(True)
                self.stop_limit_check.setChecked(True)
            elif self.action_type == Constants.SELL and high_low == Constants.LOW:
                self.profit_limit_field.setValue(price_level)
                self.profit_take_check.setChecked(True)
        elif tab_name == "OCO":
            if self.combo_action_type == Constants.SELL and high_low == Constants.HIGH:
                self.combo_limit_field.setValue(price_level-price_margin)
            elif self.combo_action_type == Constants.SELL and high_low == Constants.LOW:
                self.combo_sl_trigger_field.setValue(price_level-price_margin)
                self.combo_stop_limit_field.setValue(price_level-(price_margin*2))
            elif self.combo_action_type == Constants.BUY and high_low == Constants.HIGH:
                self.combo_sl_trigger_field.setValue(price_level+price_margin)
                self.combo_stop_limit_field.setValue(price_level+(price_margin*2))
            elif self.combo_action_type == Constants.BUY and high_low == Constants.LOW:
                self.combo_limit_field.setValue(price_level+price_margin)
        elif tab_name == "Stairstep":
            self.step_profit_price_spin.setValue(price_level)
            self.step_profit_price_radio.setChecked(True)


    def fillOutPriceFields(self, button=None, include_profit_loss=False):
        print("TradeMaker.fillOutPriceFields")
        if button == self.ask_price_button:
            limit_price = self.latest_ask
        elif button == self.bid_price_button:
            limit_price = self.latest_bid
        else:
            limit_price = self.latest_trade
        
        self.limit_field.setValue(limit_price)

        if include_profit_loss:
            if self.action_type == Constants.BUY:
                price_offset = 1
            else:
                price_offset = -1
            
            self.profit_limit_field.setValue(limit_price+price_offset)
            self.stop_trigger_field.setValue(limit_price-price_offset)
            self.stop_limit_field.setValue(limit_price-(price_offset*2))

            self.combo_limit_field.setValue(limit_price+price_offset)
            self.combo_sl_trigger_field.setValue(limit_price-price_offset)
            self.combo_stop_limit_field.setValue(limit_price-(price_offset*2))
        

    @pyqtSlot(QAbstractButton, bool)
    def buySellSelection(self, button, value):
        print("TradeMaker.buySellSelection")
        if button == self.buy_radio and value:
            self.action_type = Constants.BUY
            self.combo_sell_radio.setChecked(True)
            self.submit_button.setText(Constants.BUY)
        elif button == self.sell_radio and value:
            self.action_type = Constants.SELL
            self.combo_buy_radio.setChecked(True)
            self.submit_button.setText(Constants.SELL)
 

    def comboBuySellSelection(self, button, value):
        if button == self.combo_buy_radio and value:
            self.combo_action_type = Constants.BUY
            self.oco_button.setText("Place Buy")
        elif button == self.combo_sell_radio and value:
            self.combo_action_type = Constants.SELL
            self.oco_button.setText("Place Sell")


    def stepBuySellSelection(self, button, value):
        if button == self.step_buy_radio and value:
            self.step_action_type = Constants.BUY
            self.step_entry_trigger_offset_box.setValue(0.01)
            self.step_entry_limit_offset_box.setValue(0.1)
            self.step_stop_trigger_offset_box.setValue(-0.1)
            self.step_stop_limit_offset_box.setValue(-0.1)
        elif button == self.step_sell_radio and value:
            self.step_action_type = Constants.SELL
            self.step_entry_trigger_offset_box.setValue(-0.01)
            self.step_entry_limit_offset_box.setValue(-0.1)
            self.step_stop_trigger_offset_box.setValue(0.1)
            self.step_stop_limit_offset_box.setValue(0.1)


    def stepProfitSelection(self, button, value):
        if button == self.step_profit_factor_radio and value:
            self.step_profit_type = 'Factor'
        elif button == self.step_profit_offset_radio and value:
            self.step_profit_type = 'Offset'
        elif button == self.step_profit_price_radio and value:
            self.step_profit_type = 'Price'

        self.step_prop_update_signal.emit({'profit_type': self.step_profit_type})
        print(f"We set it to: {self.step_profit_type}")
        

    def stopLimitCheck(self, value):
        print(f"TradeMaker.stopLimitCheck {value} {Qt.Checked}")
        self.stop_limit_on = (value == Qt.Checked)
        
        if self.stop_limit_on:
            self.stop_loss_on = True
            self.stop_loss_check.setChecked(self.stop_loss_on)

    def stoplossCheck(self, value):
        print("TradeMaker.stoplossCheck")
        self.stop_loss_on = value

        # if not self.stop_loss_on:
        #     self.stop_limit_check.setChecked(self.stop_limit_on)


    def profitTakeCheck(self, value):
        self.profit_take_on = value
        self.profit_limit_field.setEnabled(value)


    def stepProfitTakeCheck(self, value):
        self.step_profit_take = value
        self.step_prop_update_signal.emit({'profit_take_on': value})
        self.step_profit_factor_spin.setEnabled(value)
        self.step_profit_offset_spin.setEnabled(value)
        self.step_profit_price_spin.setEnabled(value)
        self.step_profit_factor_radio.setEnabled(value)
        self.step_profit_offset_radio.setEnabled(value)
        self.step_profit_price_radio.setEnabled(value)

        
    def stepStoplossCheck(self, value):
        self.step_stop_loss = value
        self.step_prop_update_signal.emit({'stop_loss_on': value})
        self.step_stop_limit_offset_box.setEnabled(value)
        self.step_stop_limit_label.setEnabled(value)

        self.step_stop_trigger_offset_box.setEnabled(value)
        self.step_stop_trigger_label.setEnabled(value)


        #TODO this should be in super
    def accepts(self, value):
        return False


    def stepLevelChange(self, updated_offset, level_type):
        self.step_prop_update_signal.emit({level_type: updated_offset})
    

    def closeEvent(self, *args, **kwargs):
        pass
        
        


