
# Copyright (c) 2024 Jelmer de Vries
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation in its latest version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.


# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'optionsGraph.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5 import QtCore
from PyQt5.QtCore import pyqtSlot, QThread, pyqtSignal, Qt

import pandas as pd
import numpy as np
from dataHandling.Constants import Constants
from .DataDownloaderWindow import DataDownloaderWindow
from .polygonDownloader import PolygonDownloader

from uiComps.customWidgets.TaskProgressWindow import TaskProgressWindow

from dataHandling.UserDataManagement import readStockList

from generalFunctionality.GenFunctions import dateToReadableString
from datetime import datetime
from dateutil.relativedelta import relativedelta


class DataDownloader(DataDownloaderWindow):

    bar_types = ['1 minute','2 minute','3 minute','5 minute','15 minute', '30 minute', '1 hour', '2 hour', '4 hour', '12 hour', '1 day', '3 day']

    timer = None
    download_selection = "Whole List"
    data_processor = None
    status_window = None

    polygon_list_download = pyqtSignal(list, list, tuple)


    def __init__(self, processor_thread):
        super().__init__(self.bar_types)

        file_name, _ = self.stock_lists[0]
        self.stock_list = readStockList(file_name)

        self.selected_key = list(self.stock_list.keys())[0]
        self.selected_bar_type = self.bar_types[0]


        self.prepPolygonDownloader(processor_thread)
        self.generateColumnNames() #TODO: this is a bit ugly
        self.resetTickerList()
        self.resetDataFrames()


    def prepPolygonDownloader(self, processor_thread):
        self.polygonDownloader = PolygonDownloader()
        self.polygonDownloader.api_updater.connect(self.apiUpdate, Qt.QueuedConnection)
        self.polygon_list_download.connect(self.polygonDownloader.downloadForSymbols, Qt.QueuedConnection)

        self.polygon_thread = processor_thread
        self.polygonDownloader.moveToThread(self.polygon_thread)

        self.polygon_thread.started.connect(self.polygonDownloader.run)
        self.polygon_thread.start()


    def getCurrentKey(self):
        return (self.selected_key, self.selected_bar_type)


    def resetDataFrames(self):
        pass
        # if self.hasDataForCurrentKey():
        #     self.resetCounts()
        #     self.resetDataPoints()
        #     self.resetRanges()
        # else:
        #     self.data_count_frame = pd.DataFrame(columns=self.count_columns)
        #     self.data_frame_ranges = pd.DataFrame(columns=self.range_columns)
        #     self.data_frame_points = pd.DataFrame(columns=self.point_columns)


    def resetCounts(self):
        # Initialize an empty dataframe to store results
        self.data_count_frame = pd.DataFrame()

        for key, df in self.buffered_manager.existing_buffers.items():
            if key[0] == self.selected_key:

                counts = df.between_time('09:30', '16:00').resample('D').count().iloc[:, 0]
                # The counts Series will have as index the dates and the counts as values
                # Convert it to DataFrame and rename the column with the name of the current dataframe
                counts.replace(0, np.nan, inplace=True)

                counts = counts.to_frame(name=str(key[1]))
                # If data_count_frame is empty, assign directly
                if self.data_count_frame.empty:
                    self.data_count_frame = counts
                # If not, join with existing dataframe
                else:
                    self.data_count_frame = self.data_count_frame.join(counts, how='outer')

        print(self.data_count_frame)
        self.data_count_frame = self.data_count_frame.reindex(columns=self.count_columns)
        self.data_count_frame.dropna(how='all', inplace=True)


    def resetDataPoints(self):
        key_tuple = (self.selected_key, self.selected_bar_type)
        self.data_frame_points = self.buffered_manager.existing_buffers[key_tuple]
        

    def resetRanges(self):

        self.data_frame_ranges = pd.DataFrame(columns=self.range_columns)

        for key, df in self.buffered_manager.existing_buffers.items():
            if key[0] == self.selected_key:
                curr_ranges = df.attrs['ranges']
                ranges_df = pd.DataFrame(curr_ranges, columns=['Start', 'End'])
                ranges_df['Time frame'] = key[1]
                self.data_frame_ranges = pd.concat([self.data_frame_ranges, ranges_df], axis=0)


    def resetTickerList(self):
        self.ticker_selector.blockSignals(True)
        self.ticker_selector.clear()
        for uid, stock_inf in self.stock_list.items():
            self.ticker_selector.addItem(stock_inf[Constants.SYMBOL])
        self.ticker_selector.blockSignals(False)


    def updateTables(self):
        pass

        # self.data_count_model.setDataFrame(self.data_count_frame)
        # self.data_point_model.setDataFrame(self.data_frame_points)
        # self.data_ranges_model.setDataFrame(self.data_frame_ranges)
        # self.trade_plot.clearPlot()
        # self.trade_plot.setHistoricalData(self.data_frame_points.copy())

        # self.data_ranges_model.layoutChanged.emit()
        # self.data_point_model.layoutChanged.emit()
        # self.data_count_model.layoutChanged.emit()
        

    def generateColumnNames(self):
        self.count_columns = self.bar_types
        self.point_columns = [Constants.OPEN, Constants.CLOSE, Constants.LOW, Constants.HIGH, Constants.VOLUME]
        self.range_columns = ['Time frame', 'Start', 'End']

        
    def initDataModels(self):
        pass
        # Print the DataFrame

        # mapping = {0: '__INDEX__'}
        # for index, bar_type in enumerate(self.bar_types):
        #     mapping[index+1] = bar_type
        # header_labels = ['Date', '5 min', '15 min', '1 hour', '4 hour', '1 day']
        # self.data_count_model = PandasDataModel(self.data_count_frame, mapping, header_labels=header_labels)
        # self.data_count_table.setModel(self.data_count_model)
        # self.data_count_model.api_updater.connect(self.processingUpdate)


        # mapping = {0: '__INDEX__', 1: Constants.OPEN, 2: Constants.CLOSE, 3: Constants.LOW, 4: Constants.HIGH, 5: Constants.VOLUME}
        # header_labels = ['Time', 'Open', 'Close', 'Low', 'High', 'Volume']
        # self.data_point_model = PandasDataModel(self.data_frame_points, mapping, header_labels=header_labels)
        # self.data_point_table.setModel(self.data_point_model)
        # self.data_point_model.api_updater.connect(self.processingUpdate)


        # mapping = {0: 'Time frame', 1: 'Start', 2: 'End'}
        # self.data_ranges_model = PandasDataModel(self.data_frame_ranges, mapping)
        # self.data_ranges_table.setModel(self.data_ranges_model)
        # self.data_ranges_model.api_updater.connect(self.processingUpdate)

        # self.models = [self.overview_model, self.low_model, self.high_model, self.step_up_model, self.step_down_model, self.rsi_model, self.rel_rsi_model, self.index_corr_model]
        # for model in self.models: model.greyout_stale = self.use_stale_box.isChecked()

############## DATA PROCESSING


    @pyqtSlot(str, dict)
    def apiUpdate(self, signal, sub_signal):
        print(f"DataDownloader.apiUpdate {signal}")
        if signal == Constants.POLYGON_REQUEST_COMPLETED:
            print("We receive polygon data!")
            print(sub_signal)
            self.download_counter += 1
            self.statusBar.showMessage(f"Downloaded {self.download_counter} of {self.total_count}")
        elif signal == Constants.POLYGON_REQUESTS_COMPLETED:
            self.statusBar.showMessage(f"All Data Requests Downloaded")
            self.download_button.setEnabled(True)


    def getBarFromPolygonType(self, polygon_bar):
        split_polygon_bar = polygon_bar.split()
        count = int(split_polygon_bar[0])
        unit = split_polygon_bar[1]

        if unit == 'minute':
            unit = 'min'
        elif unit == 'hour':
            unit = 'hour'

        if count > 1:
            unit += 's'
        return f"{count} {unit}"


    def listSelection(self, value):
        file_name, _ = self.stock_lists[value]
        self.stock_list = readStockList(file_name)
        self.selected_key = list(self.stock_list.keys())[0]
        self.resetTickerList()
        

    def barChecksChanged(self, value):
        self.bar_selection[self.bar_types[value]] = self.download_bar_selector.itemState(value)


    def createStatusWindow(self):
        requests = self.history_manager.request_buffer
        data = {
            "Req ID": [req.req_id for req in requests],
            "Ticker ID": [req.contract.symbol for req in requests],
            "Bars": [f"{req.bar_type}" for req in requests],
            "Duration": [f"{req.period_string}" for req in requests],
            "End Date": [f"{dateToReadableString(req.end_date)}" for req in requests],
            "Status": ["-1: Pending"] * len(requests)
        }

        task_frame = pd.DataFrame(data)

        self.status_window = TaskProgressWindow(task_frame)
        self.status_window.setMinimumSize(600, 400)
        self.status_window.show()
        


############## GUI SIGNALING

    def radioSelection(self, value):
        if self.rb_single_ticker.isChecked():
            self.download_selection = "Single Ticker"
            self.download_list_checker.setEnabled(False)
        elif self.rb_all_lists.isChecked():
            self.download_selection = "Multiple Lists"
            self.download_list_checker.setEnabled(True)
        elif self.rb_whole_list.isChecked():
            self.download_selection = "Whole List"
            self.download_list_checker.setEnabled(False)


    def tickerSelection(self, value):
        ordered_keys = list(self.stock_list.keys())
        self.selected_key = ordered_keys[value]
        self.resetDataFrames()
        self.updateTables()
        self.ticker_description_label.setText(self.stock_list[self.selected_key]['long_name'])


    def downloadData(self):
        
        current_date = datetime.now()
        start_date = current_date - relativedelta(years=5)
        print(f"DataDetails.downloadPolygonData {start_date}")

        bar_types = [bar_type for bar_type, checked in self.bar_selection.items() if checked]

        if self.download_selection == "Single Ticker":
            self.download_button.setEnabled(False)
            symbol = self.stock_list[self.selected_key][Constants.SYMBOL]
            self.total_count = len(bar_types)
            self.polygon_list_download.emit([symbol], bar_types, (start_date, current_date))
        elif self.download_selection == "Whole List":
            self.download_button.setEnabled(False)

            symbol_list = [stock_info[Constants.SYMBOL] for stock_info in self.stock_list.values()]
            self.total_count = len(bar_types) * len(symbol_list)
            self.polygon_list_download.emit(symbol_list, bar_types, (start_date, current_date))
        elif self.download_selection == "Multiple Lists":
            print("THIS OPTION IS NOT IMPLEMENTED")

        self.download_counter = 0
        self.statusBar.showMessage(f"Downloaded {self.download_counter} of {self.total_count}")


    def timeFramePointSel(self, value):
        self.selected_bar_type = self.bar_types[value]
        self.bar_selector_graph.setCurrentIndex(value)
        self.resetDataPoints()
        self.updateTables()


    def timeFrameGraphSel(self, value):
        self.selected_bar_type = self.bar_types[value]
        self.bar_selector_point.setCurrentIndex(value)
        self.resetDataPoints()
        self.updateTables()


    def processingUpdate(self, signal):
        print(f"DataDetails.processingUpdate {signal}")
        if signal == Constants.DATA_WILL_CHANGE:
            pass
        elif signal == Constants.DATA_DID_CHANGE:
            self.data_count_model.layoutChanged.emit()
            self.data_point_model.layoutChanged.emit()
            self.data_ranges_model.layoutChanged.emit()

    
    def signalCurrentTable(self):
        current_index = self.tab_widget.currentIndex()
        current_model = self.list_of_tables[current_index].model()
        current_model.layoutChanged.emit()
        current_model.dataChanged.emit(QtCore.QModelIndex(), QtCore.QModelIndex())



